{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useContext, useEffect, useState, useRef, useCallback } from 'react'; // Add useCallback\nimport { Button, Form, Dropdown, ListGroup, Container, Row, Col, Alert } from 'react-bootstrap';\nimport axios from 'axios';\nimport SockJS from 'sockjs-client';\nimport { Stomp } from '@stomp/stompjs';\nimport NavBar from \"../../components/Navbar\";\nimport { LoggedUserContext } from '../../context/LoggedUserContext';\nimport \"../../styles/ChatGroup.css\";\nfunction GroupChatApp() {\n  _s();\n  const [groups, setGroups] = useState([]);\n  const [selectedGroup, setSelectedGroup] = useState('');\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState('');\n  const [notifications, setNotifications] = useState([]);\n  const [unreadNotifications, setUnreadNotifications] = useState(0);\n  const {\n    loggedUser\n  } = useContext(LoggedUserContext);\n  const stompClient = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const currentGroupSubscription = useRef(null); // To manage group-specific subscription\n\n  // ... (fetchGroups, removeNotification, markNotificationAsRead, switchToGroupFromNotification, getMessageText, formatTimestamp - these can remain largely the same)\n\n  // WebSocket connection setup\n  useEffect(() => {\n    const socket = new SockJS('http://localhost:8080/socket');\n    stompClient.current = Stomp.over(socket);\n    stompClient.current.connect({}, frame => {\n      console.log('Connected to WebSocket:', frame);\n      setIsConnected(true);\n\n      // Subscribe to GLOBAL notifications\n      stompClient.current.subscribe('/topic/notifications', message => {\n        const notification = JSON.parse(message.body);\n        handleWebSocketNotification(notification);\n      });\n    }, error => {\n      console.error('WebSocket connection error:', error);\n      setIsConnected(false);\n      // Consider adding a reconnect logic here for production apps\n    });\n    return () => {\n      if (stompClient.current) {\n        stompClient.current.disconnect();\n      }\n    };\n  }, []); // Empty dependency array means this runs once on mount\n\n  // Handle incoming WebSocket notifications\n  const handleWebSocketNotification = useCallback(notification => {\n    if (notification.type === 'NEW_MESSAGE') {\n      const currentUserFullName = loggedUser ? `${loggedUser.firstName} ${loggedUser.lastName}` : null;\n\n      // Don't show notification for your own messages\n      // And ensure sender is defined before comparing\n      if (currentUserFullName && notification.sender === currentUserFullName) {\n        return;\n      }\n\n      // If user is NOT viewing this group, show notification\n      // Also, ensure notification.groupId is available for comparison with currently selected group's ID\n      const currentSelectedGroupObject = groups.find(g => g.name === selectedGroup);\n      const currentSelectedGroupId = currentSelectedGroupObject ? currentSelectedGroupObject.id : null;\n      if (!currentSelectedGroupId || currentSelectedGroupId !== notification.groupId) {\n        const newNotification = {\n          id: Date.now(),\n          type: 'message',\n          groupName: notification.groupName,\n          groupId: notification.groupId,\n          sender: notification.sender,\n          message: notification.message,\n          timestamp: new Date(notification.timestamp),\n          read: false\n        };\n        setNotifications(prev => [newNotification, ...prev].slice(0, 10));\n        setUnreadNotifications(prev => prev + 1);\n        setTimeout(() => {\n          removeNotification(newNotification.id);\n        }, 10000); // Auto-remove after 10 seconds\n      }\n    }\n  }, [loggedUser, selectedGroup, groups]); // Add dependencies\n\n  useEffect(() => {\n    fetchGroups();\n  }, []);\n\n  // Effect for handling group selection and subscribing to group-specific messages\n  useEffect(() => {\n    if (!selectedGroup || !stompClient.current || !isConnected) {\n      // If a group was previously selected, unsubscribe from its topic\n      if (currentGroupSubscription.current) {\n        currentGroupSubscription.current.unsubscribe();\n        currentGroupSubscription.current = null;\n      }\n      setMessages([]); // Clear messages when no group is selected or connection is lost\n      return;\n    }\n    const group = groups.find(g => g.name === selectedGroup);\n    if (!group) {\n      console.warn(`Selected group \"${selectedGroup}\" not found in fetched groups.`);\n      setMessages([]);\n      return;\n    }\n\n    // Fetch initial messages for the selected group\n    const fetchInitialMessages = async () => {\n      try {\n        const res = await axios.get(`http://localhost:8080/message/${group.id}`);\n        setMessages(res.data);\n      } catch (err) {\n        console.error('Error fetching initial messages:', err);\n      }\n    };\n    fetchInitialMessages();\n\n    // Unsubscribe from previous group's topic if any\n    if (currentGroupSubscription.current) {\n      currentGroupSubscription.current.unsubscribe();\n    }\n\n    // Subscribe to the specific group's chat topic\n    const subscription = stompClient.current.subscribe(`/topic/group/${group.id}`, message => {\n      const newMessage = JSON.parse(message.body);\n      // Check if the message is from the currently selected group to avoid race conditions or out-of-order updates\n      if (newMessage.group.id === group.id) {\n        setMessages(prevMessages => [...prevMessages, newMessage]);\n      }\n    });\n    currentGroupSubscription.current = subscription; // Store the subscription object\n\n    // Cleanup function for when the component unmounts or selectedGroup changes\n    return () => {\n      if (currentGroupSubscription.current) {\n        currentGroupSubscription.current.unsubscribe();\n        currentGroupSubscription.current = null;\n      }\n    };\n  }, [selectedGroup, groups, isConnected]); // Re-run when selectedGroup or groups or connection status changes\n\n  // ... (handleSend, handleCreateGroup, getMessageText, formatTimestamp - these can remain the same or minor tweaks if using the direct WebSocket message push)\n  // handleSend should not re-fetch all messages after sending. Instead, rely on the WebSocket push.\n  const handleSend = async () => {\n    if (!inputValue.trim() || !selectedGroup || !stompClient.current || !isConnected) return;\n    const group = groups.find(g => g.name === selectedGroup);\n    if (!group) {\n      console.error(\"Selected group not found\");\n      return;\n    }\n    const messagePayload = {\n      sender: `${loggedUser.firstName} ${loggedUser.lastName}`,\n      message: inputValue,\n      groupId: group.id // Include groupId in the payload for backend\n    };\n    try {\n      // Send message via HTTP POST for persistence\n      await axios.post(`http://localhost:8080/message/post?groupChatId=${group.id}`, messagePayload);\n\n      // Clear input only after successful send\n      setInputValue('');\n      // No need to fetch messages here, the WebSocket will push the new message\n    } catch (err) {\n      console.error('Sending message failed:', err);\n    }\n  };\n\n  // ... (return statement - no major changes needed here, as the UI logic remains similar)\n}\n_s(GroupChatApp, \"jckk37Hp1ReTUmjf2lzI1MdgekQ=\");\n_c = GroupChatApp;\nexport default GroupChatApp;\nvar _c;\n$RefreshReg$(_c, \"GroupChatApp\");","map":{"version":3,"names":["React","useContext","useEffect","useState","useRef","useCallback","Button","Form","Dropdown","ListGroup","Container","Row","Col","Alert","axios","SockJS","Stomp","NavBar","LoggedUserContext","GroupChatApp","_s","groups","setGroups","selectedGroup","setSelectedGroup","messages","setMessages","inputValue","setInputValue","notifications","setNotifications","unreadNotifications","setUnreadNotifications","loggedUser","stompClient","isConnected","setIsConnected","currentGroupSubscription","socket","current","over","connect","frame","console","log","subscribe","message","notification","JSON","parse","body","handleWebSocketNotification","error","disconnect","type","currentUserFullName","firstName","lastName","sender","currentSelectedGroupObject","find","g","name","currentSelectedGroupId","id","groupId","newNotification","Date","now","groupName","timestamp","read","prev","slice","setTimeout","removeNotification","fetchGroups","unsubscribe","group","warn","fetchInitialMessages","res","get","data","err","subscription","newMessage","prevMessages","handleSend","trim","messagePayload","post","_c","$RefreshReg$"],"sources":["E:/AN3/SEM2/project-MichiMauser/frontend/src/pages/webSocket/WebSocketMsg.js"],"sourcesContent":["import React, { useContext, useEffect, useState, useRef, useCallback } from 'react'; // Add useCallback\r\nimport { Button, Form, Dropdown, ListGroup, Container, Row, Col, Alert } from 'react-bootstrap';\r\nimport axios from 'axios';\r\nimport SockJS from 'sockjs-client';\r\nimport { Stomp } from '@stomp/stompjs';\r\nimport NavBar from \"../../components/Navbar\";\r\nimport { LoggedUserContext } from '../../context/LoggedUserContext';\r\nimport \"../../styles/ChatGroup.css\";\r\n\r\nfunction GroupChatApp() {\r\n    const [groups, setGroups] = useState([]);\r\n    const [selectedGroup, setSelectedGroup] = useState('');\r\n    const [messages, setMessages] = useState([]);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [notifications, setNotifications] = useState([]);\r\n    const [unreadNotifications, setUnreadNotifications] = useState(0);\r\n    const {loggedUser} = useContext(LoggedUserContext);\r\n    const stompClient = useRef(null);\r\n    const [isConnected, setIsConnected] = useState(false);\r\n    const currentGroupSubscription = useRef(null); // To manage group-specific subscription\r\n\r\n    // ... (fetchGroups, removeNotification, markNotificationAsRead, switchToGroupFromNotification, getMessageText, formatTimestamp - these can remain largely the same)\r\n\r\n    // WebSocket connection setup\r\n    useEffect(() => {\r\n        const socket = new SockJS('http://localhost:8080/socket');\r\n        stompClient.current = Stomp.over(socket);\r\n\r\n        stompClient.current.connect({}, (frame) => {\r\n            console.log('Connected to WebSocket:', frame);\r\n            setIsConnected(true);\r\n\r\n            // Subscribe to GLOBAL notifications\r\n            stompClient.current.subscribe('/topic/notifications', (message) => {\r\n                const notification = JSON.parse(message.body);\r\n                handleWebSocketNotification(notification);\r\n            });\r\n        }, (error) => {\r\n            console.error('WebSocket connection error:', error);\r\n            setIsConnected(false);\r\n            // Consider adding a reconnect logic here for production apps\r\n        });\r\n\r\n        return () => {\r\n            if (stompClient.current) {\r\n                stompClient.current.disconnect();\r\n            }\r\n        };\r\n    }, []); // Empty dependency array means this runs once on mount\r\n\r\n    // Handle incoming WebSocket notifications\r\n    const handleWebSocketNotification = useCallback((notification) => {\r\n        if (notification.type === 'NEW_MESSAGE') {\r\n            const currentUserFullName = loggedUser ? `${loggedUser.firstName} ${loggedUser.lastName}` : null;\r\n\r\n            // Don't show notification for your own messages\r\n            // And ensure sender is defined before comparing\r\n            if (currentUserFullName && notification.sender === currentUserFullName) {\r\n                return;\r\n            }\r\n\r\n            // If user is NOT viewing this group, show notification\r\n            // Also, ensure notification.groupId is available for comparison with currently selected group's ID\r\n            const currentSelectedGroupObject = groups.find(g => g.name === selectedGroup);\r\n            const currentSelectedGroupId = currentSelectedGroupObject ? currentSelectedGroupObject.id : null;\r\n\r\n\r\n            if (!currentSelectedGroupId || currentSelectedGroupId !== notification.groupId) {\r\n                const newNotification = {\r\n                    id: Date.now(),\r\n                    type: 'message',\r\n                    groupName: notification.groupName,\r\n                    groupId: notification.groupId,\r\n                    sender: notification.sender,\r\n                    message: notification.message,\r\n                    timestamp: new Date(notification.timestamp),\r\n                    read: false\r\n                };\r\n\r\n                setNotifications(prev => [newNotification, ...prev].slice(0, 10));\r\n                setUnreadNotifications(prev => prev + 1);\r\n\r\n                setTimeout(() => {\r\n                    removeNotification(newNotification.id);\r\n                }, 10000); // Auto-remove after 10 seconds\r\n            }\r\n        }\r\n    }, [loggedUser, selectedGroup, groups]); // Add dependencies\r\n\r\n    useEffect(() => {\r\n        fetchGroups();\r\n    }, []);\r\n\r\n    // Effect for handling group selection and subscribing to group-specific messages\r\n    useEffect(() => {\r\n        if (!selectedGroup || !stompClient.current || !isConnected) {\r\n            // If a group was previously selected, unsubscribe from its topic\r\n            if (currentGroupSubscription.current) {\r\n                currentGroupSubscription.current.unsubscribe();\r\n                currentGroupSubscription.current = null;\r\n            }\r\n            setMessages([]); // Clear messages when no group is selected or connection is lost\r\n            return;\r\n        }\r\n\r\n        const group = groups.find(g => g.name === selectedGroup);\r\n        if (!group) {\r\n            console.warn(`Selected group \"${selectedGroup}\" not found in fetched groups.`);\r\n            setMessages([]);\r\n            return;\r\n        }\r\n\r\n        // Fetch initial messages for the selected group\r\n        const fetchInitialMessages = async () => {\r\n            try {\r\n                const res = await axios.get(`http://localhost:8080/message/${group.id}`);\r\n                setMessages(res.data);\r\n            } catch (err) {\r\n                console.error('Error fetching initial messages:', err);\r\n            }\r\n        };\r\n\r\n        fetchInitialMessages();\r\n\r\n        // Unsubscribe from previous group's topic if any\r\n        if (currentGroupSubscription.current) {\r\n            currentGroupSubscription.current.unsubscribe();\r\n        }\r\n\r\n        // Subscribe to the specific group's chat topic\r\n        const subscription = stompClient.current.subscribe(`/topic/group/${group.id}`, (message) => {\r\n            const newMessage = JSON.parse(message.body);\r\n            // Check if the message is from the currently selected group to avoid race conditions or out-of-order updates\r\n            if (newMessage.group.id === group.id) {\r\n                setMessages(prevMessages => [...prevMessages, newMessage]);\r\n            }\r\n        });\r\n        currentGroupSubscription.current = subscription; // Store the subscription object\r\n\r\n        // Cleanup function for when the component unmounts or selectedGroup changes\r\n        return () => {\r\n            if (currentGroupSubscription.current) {\r\n                currentGroupSubscription.current.unsubscribe();\r\n                currentGroupSubscription.current = null;\r\n            }\r\n        };\r\n    }, [selectedGroup, groups, isConnected]); // Re-run when selectedGroup or groups or connection status changes\r\n\r\n    // ... (handleSend, handleCreateGroup, getMessageText, formatTimestamp - these can remain the same or minor tweaks if using the direct WebSocket message push)\r\n    // handleSend should not re-fetch all messages after sending. Instead, rely on the WebSocket push.\r\n    const handleSend = async () => {\r\n        if (!inputValue.trim() || !selectedGroup || !stompClient.current || !isConnected) return;\r\n\r\n        const group = groups.find(g => g.name === selectedGroup);\r\n        if (!group) {\r\n            console.error(\"Selected group not found\");\r\n            return;\r\n        }\r\n\r\n        const messagePayload = {\r\n            sender: `${loggedUser.firstName} ${loggedUser.lastName}`,\r\n            message: inputValue,\r\n            groupId: group.id // Include groupId in the payload for backend\r\n        };\r\n\r\n        try {\r\n            // Send message via HTTP POST for persistence\r\n            await axios.post(`http://localhost:8080/message/post?groupChatId=${group.id}`, messagePayload);\r\n\r\n            // Clear input only after successful send\r\n            setInputValue('');\r\n            // No need to fetch messages here, the WebSocket will push the new message\r\n        } catch (err) {\r\n            console.error('Sending message failed:', err);\r\n        }\r\n    };\r\n\r\n    // ... (return statement - no major changes needed here, as the UI logic remains similar)\r\n}\r\n\r\nexport default GroupChatApp;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}